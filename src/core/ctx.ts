import { promises as fs } from 'node:fs'
import { dirname, isAbsolute, relative, resolve } from 'node:path'
import process from 'node:process'
import { slash, toArray } from '@antfu/utils'
import { isPackageExists } from 'local-pkg'
import { createUnimport, resolvePreset } from 'unimport'
import { presets } from '../presets'
import { resolversAddon } from './resolvers'
import type { Import, InlinePreset } from 'unimport'
import type { Options } from '../types'

export const INCLUDE_RE_LIST = [/\.[jt]sx?$/]
export const EXCLUDE_RE_LIST = [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/]

export function createContext(options: Options = {}, root = process.cwd()) {
  root = slash(root)

  const {
    dts: preferDTS = isPackageExists('typescript'),
    dtsPreserveExts = false,
    dirsScanOptions,
    dirs,
  } = options

  const resolvers = options.resolvers ? [options.resolvers].flat(2) : []

  // When "options.injectAtEnd" is undefined or true, it's true.
  const injectAtEnd = options.injectAtEnd !== false

  const unimport = createUnimport({
    imports: [],
    presets:
      options.packagePresets?.map((p) =>
        typeof p === 'string' ? { package: p } : p,
      ) ?? [],
    dirsScanOptions: {
      ...dirsScanOptions,
      cwd: root,
    },
    dirs,
    injectAtEnd,
    parser: options.parser,
    addons: {
      addons: [
        resolversAddon(resolvers),
        {
          name: 'unplugin-auto-import:dts',
          declaration(dts) {
            return `${`
/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-auto-import
// biome-ignore lint: disable
${dts}`.trim()}\n`
          },
        },
      ],
    },
  })

  const importsPromise = flattenImports(options.imports).then((imports) => {
    if (!imports.length && !resolvers.length && !dirs?.length)
      console.warn(
        '[auto-import] plugin installed but no imports has defined, see https://github.com/antfu/unplugin-auto-import#configurations for configurations',
      )

    const compare = (
      left: string | undefined,
      right: NonNullable<Options['ignore'] | Options['ignoreDts']>[number],
    ) => {
      return right instanceof RegExp ? right.test(left!) : right === left
    }

    options.ignore?.forEach((name) => {
      const i = imports.find((i) => compare(i.as, name))
      if (i) i.disabled = true
    })

    options.ignoreDts?.forEach((name) => {
      const i = imports.find((i) => compare(i.as, name))
      if (i) i.dtsDisabled = true
    })

    return unimport.getInternalContext().replaceImports(imports)
  })

  const dts =
    preferDTS === false
      ? false
      : preferDTS === true
        ? resolve(root, 'auto-imports.d.ts')
        : resolve(root, preferDTS)

  async function generateDTS(file: string) {
    await importsPromise
    const dir = dirname(file)
    const currentContent = await unimport.generateTypeDeclarations({
      resolvePath: (i) => {
        if (i.from.startsWith('.') || isAbsolute(i.from)) {
          const related = slash(
            dtsPreserveExts
              ? relative(dir, i.from)
              : relative(dir, i.from).replace(/\.ts(x)?$/, ''),
          )
          return !related.startsWith('.') ? `./${related}` : related
        }
        return i.from
      },
    })

    return currentContent
  }

  // eslint-disable-next-line unicorn/consistent-function-scoping
  async function writeFile(filePath: string, content = '') {
    await fs.mkdir(dirname(filePath), { recursive: true })
    return await fs.writeFile(filePath, content, 'utf-8')
  }

  let lastDTS: string | undefined

  async function writeConfigFiles() {
    const promises: any[] = []
    if (dts) {
      promises.push(
        generateDTS(dts).then((content) => {
          if (content !== lastDTS) {
            lastDTS = content
            return writeFile(dts, content)
          }
        }),
      )
    }

    return Promise.all(promises)
  }

  return {
    writeConfigFiles,
  }
}

export async function flattenImports(
  map: Options['imports'],
): Promise<Import[]> {
  const promises = await Promise.all(
    toArray(map).map(async (definition) => {
      if (typeof definition === 'string') {
        if (!presets[definition])
          throw new Error(`[auto-import] preset ${definition} not found`)
        const preset = presets[definition]
        definition = preset
      }

      if ('from' in definition && 'imports' in definition) {
        return await resolvePreset(definition as InlinePreset)
      } else {
        const resolved: Import[] = []
        for (const mod of Object.keys(definition)) {
          for (const id of definition[mod]) {
            const meta = {
              from: mod,
            } as Import
            if (Array.isArray(id)) {
              meta.name = id[0]
              meta.as = id[1]
            } else {
              meta.name = id
              meta.as = id
            }
            resolved.push(meta)
          }
        }
        return resolved
      }
    }),
  )

  return promises.flat()
}
